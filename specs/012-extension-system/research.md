# Research: Extension System

**Feature**: 012-extension-system
**Date**: 2026-02-21

## R1: How to serve extension static files without backend changes

**Decision**: Use Vite's `public/` directory copy + build-time copy plugin.

**Rationale**: Extensions live at `extensions/` in the project root. During development, Vite can serve them via a custom plugin that aliases `/extensions/*` to the filesystem. At build time, extension UI files are copied into `frontend/dist/extensions/`. The existing Express static file server (`express.static(frontendDist)`) then serves them automatically — no backend route changes needed.

**Alternatives considered**:
- **Backend route** (`/api/extensions/*`): Violates the "no backend changes" constraint.
- **Vite `public/` symlink**: Fragile across OS and build environments.
- **Inline extensions in frontend bundle**: Defeats the purpose of extensions being separate, droppable folders.

**Implementation**: A Vite plugin (`vite-plugin-extensions`) that:
1. In dev mode: intercepts requests matching `/extensions/*` and serves from `../extensions/`
2. At build time: copies `extensions/*/ui/` to `dist/extensions/*/ui/`

---

## R2: How to extend the panel type system dynamically

**Decision**: Extend `PanelContent` to accept `ext:<extension-name>` string values.

**Rationale**: The current panel system uses a union type `'none' | 'files' | 'git' | 'preview' | 'issues'`. Adding dynamic extension panels requires either expanding this union or using a string prefix convention. The prefix `ext:<name>` (e.g., `ext:frontend-design`) keeps built-in panels as literal types while allowing arbitrary extension panels. The `renderPanelContent` function adds an `else if (contentType.startsWith('ext:'))` branch that renders `<ExtensionPanel>`.

**Alternatives considered**:
- **Expanding the union type per extension**: Requires code changes for each new extension — defeats the purpose.
- **Using a generic `extension` panel type with sub-state**: Adds unnecessary complexity; the string prefix is simpler.

---

## R3: postMessage protocol design

**Decision**: Structured JSON messages with `type` discriminator, validated on both sides.

**Rationale**: The host and extension iframe communicate via `window.postMessage`. Messages must be structured to distinguish between different operations. A `type` field serves as the discriminator. The host validates the source (iframe reference) before processing.

**Protocol**:

**Host → Extension (inbound to iframe)**:
```json
{ "type": "board-command", "command": "design.add_screen", "params": { "name": "...", "html": "..." } }
{ "type": "init", "sessionId": "...", "extensionName": "..." }
```

**Extension → Host (outbound from iframe)**:
```json
{ "type": "board-command", "command": "show_panel", "params": { "panel": "files" } }
{ "type": "send-comment", "text": "...", "context": { "screen": "...", "element": "..." } }
{ "type": "ready" }
```

**Security**: Host checks `event.source` matches the extension iframe's `contentWindow`. Extension checks `event.origin` matches the host origin. Malformed messages are ignored silently.

**Alternatives considered**:
- **MessageChannel API**: More secure but harder to set up; overkill for trusted first-party extensions.
- **Custom events on parent window**: Doesn't work cross-frame.
- **SharedWorker**: Unnecessary complexity for simple message passing.

---

## R4: Skill registration without backend changes

**Decision**: Symlinks from `.claude-skills/skills/` to extension skill directories, created by a lightweight Node.js script or Vite plugin at startup.

**Rationale**: The agent discovers skills by scanning `.claude-skills/skills/` on the filesystem. Extensions declare their skills in the manifest. At application startup (or via a build step), the system creates symlinks: `.claude-skills/skills/design-add-screen → extensions/frontend-design/skills/design-add-screen`. This requires no backend code changes — it's filesystem-level registration.

**Alternatives considered**:
- **Copy files instead of symlink**: Works but creates duplication; changes to extension skills aren't reflected without re-copy.
- **Modify agent's skill scan path**: Requires backend changes to the skill discovery logic.
- **Manual symlink by the developer**: Error-prone and not discoverable.

**Implementation**: A simple Node.js script (`scripts/register-extension-skills.js`) or npm lifecycle hook (`postinstall`/`prepare`) that reads all `extensions/*/manifest.json` files and creates symlinks.

---

## R5: Frontend Design extension — screen rendering isolation

**Decision**: Render each screen's HTML inside a sandboxed `<iframe srcdoc="...">` within the extension panel.

**Rationale**: Screens contain arbitrary HTML generated by the agent. This HTML must not leak styles or scripts into the extension panel or host app. Using `srcdoc` on a sandboxed iframe provides full isolation. The extension panel (itself an iframe) contains inner iframes per screen — only the active screen's iframe is visible.

**Alternatives considered**:
- **Shadow DOM**: Provides style isolation but not script isolation. Agent-generated scripts could still access the extension's DOM.
- **Single iframe with content replacement**: Loses scroll position and comment state on switch; simpler but worse UX.
- **Blob URLs**: Works but complicates lifecycle management (need to revoke URLs).

**Implementation detail**: The `srcdoc` attribute is set from the HTML content received via board command. The sandbox attribute is `allow-scripts` to let interactive prototypes work, but blocks top-navigation and form submission to the parent.

---

## R6: Element inspection and commenting in the design extension

**Decision**: The extension injects an overlay layer over the active screen iframe. Mouse events on the overlay are mapped to elements in the iframe's DOM via `document.elementFromPoint()` called on the iframe's `contentDocument`.

**Rationale**: The extension needs to highlight elements on hover and allow click-to-select for commenting. Since the screen content is in a sandboxed iframe, the extension can access its `contentDocument` (same-origin srcdoc) to query elements. An overlay `<div>` sits on top of the iframe and intercepts mouse events in inspect mode. The overlay translates coordinates to the iframe's coordinate space, queries the element, and draws a highlight box.

**Alternatives considered**:
- **Injecting highlight CSS into the iframe**: Modifies the screen content; could break layouts.
- **Using the browser's built-in DevTools inspect**: Not programmable.
- **Using `pointer-events: none` on the iframe and capturing on overlay**: This is the chosen approach — clean separation between interaction layer and content.

**Element description format**: When a comment is sent, the element is described as:
```
[<tagName>] "<visible text content>" (role: <aria-role if present>)
```
Example: `[button] "Submit Order" (role: button)`

---

## R7: Comment delivery format for design extension

**Decision**: Reuse the existing comment delivery mechanism (HTTP POST to `/api/sessions/:id/comments` then deliver). The comment text includes structured context as a prefix.

**Rationale**: The existing comment system already handles delivery to PTY stdin. Extension comments just need a different format. The Frontend Design extension sends comments structured as:

```
[Design Review — Screen: "Homepage"] Element: [button] "Submit Order"
Comment: Make this button larger and use the primary color.
```

This is created by the extension iframe, sent to the host via postMessage, and the host calls the existing `comments.create()` + `comments.deliverOne()` API.

**Alternatives considered**:
- **New backend endpoint**: Violates the no-backend-changes constraint.
- **Direct PTY write via WebSocket**: Bypasses the comment system; loses the ability to queue/batch comments.
- **Custom board command back to backend**: Would require backend handling code.
